# pRFC

This repository contains the Verilog HDL implementation of the **pRFC (Parallel Reconfigurable Packet Classifier)**, a high-performance, FPGA-based packet classification engine. This design is the hardware realization of the classification algorithm proposed in the research paper: ***Memory-Efficient Packet Classification at High-Speed: The pRFC Architecture with Heuristic Partitioning***.

The pRFC engine is designed to perform line-rate 5-tuple (Source IP, Destination IP, Source Port, Destination Port, Protocol) packet classification by offloading the task to dedicated hardware. It leverages a deeply pipelined architecture and multiple parallel classification units to overcome the performance limitations of traditional software-based approaches, achieving high throughput and low, deterministic latency.

The core classification strategy is based on a multi-stage memory lookup scheme, which decomposes the complex 5-tuple matching problem into a series of smaller, more manageable table lookups implemented using on-chip Block RAM (BRAM).

## Hardware Architecture & Design

The architecture is optimized for performance on FPGA platforms, centered around a pipelined data path and parallel processing units.

### Five-Stage Pipeline

The classification process for each packet is executed in a five-stage pipeline, allowing the engine to process one packet per clock cycle at steady state (excluding initial latency and stalls).

- **Stage 1: PARSE**

  - **Action:** On `packet_valid`, the input 5-tuple fields are latched into pipeline registers (`stage1_dims`).
  - **Details:** This stage serves as the entry point, isolating the core logic from input timing variations.
- **Stage 2: PHASE 0 LOOKUP**

  - **Action:** The 5-tuple components are used to form addresses for the first level of BRAM lookups (`bram_phase0`). The results (`phase0_dout`) are captured.
  - **Details:** The address for each of the six dimension tables is generated by right-shifting the corresponding 16-bit field of the 5-tuple by a pre-configured `FACTOR`. This is a form of address compression. The results from this stage are intermediate IDs.
- **Stage 3: PHASE 1 LOOKUP**

  - **Action:** The intermediate IDs from Stage 2 are combined arithmetically to generate keys for the second-level lookup (`stage2_phase1_keys`). These keys are used as addresses for the `bram_phase1` modules.
  - **Details:** The key generation is a critical step, e.g., `key = id_0 * const_1 + id_1 * const_2 + id_2`. This effectively maps a multi-dimensional space onto a linear address space for the next lookup stage.
- **Stage 4: FINAL LOOKUP**

  - **Action:** The results from the Phase 1 lookup are combined to form the final address (`stage3_final_keys`) for the last lookup stage in `bram_final`.
  - **Details:** This lookup retrieves the final classification result (e.g., a rule ID or action ID) for each parallel classifier.
- **Stage 5: OUTPUT & SELECTION**

  - **Action:** The results from all parallel classifiers (`stage4_results`) are compared. The one with the highest priority (numerically lowest value, excluding invalid markers) is selected as the final `classification_result`.
  - **Details:** The `result_valid` signal is asserted to indicate a valid output. The pipeline implements a back-pressure mechanism using `pipeline_stall = stage5_valid && !result_ready`, ensuring no data is lost if the downstream consumer is not ready.

### Parallel Classifier Architecture

To manage large rule sets and enhance throughput, the design instantiates multiple independent classifier units (`NUM_CLASSIFIERS = 4`).

- **Parallel Processing:** Each of the four classifiers processes the same input packet simultaneously.
- **Independent Rule Sets:** Each classifier has its own dedicated set of BRAMs (`bram_phase0`, `bram_phase1`, `bram_final`), which are initialized with different memory files (`.mem`). This allows a large, complex rule set to be partitioned across the classifiers.
- **Result Arbitration:** A simple priority mechanism in Stage 5 selects the final result. The `min_result` logic finds the smallest valid rule ID among all classifiers, effectively implementing a "best match" or "highest priority" policy.

## File Structure

```
├── HW_source/
│   ├── prfc_top.v              # Top-level module integrating the pipeline and all classifiers
│   ├── bram_phase0.v           # Parameterized BRAM for Phase 0 lookups
│   ├── bram_phase1.v           # Parameterized BRAM for Phase 1 lookups
│   ├── bram_final.v            # Parameterized BRAM for the final lookup
│   └── ...                     # Other logic modules (e.g., packet_parser)
│
├─ data/
│   ├── classifier_parameters.v # Verilog file defining BRAM sizes and parameters
│   ├── classifier_0_*.mem      # Memory initialization files for Classifier 0
│   ├── classifier_1_*.mem      # Memory initialization files for Classifier 1
│   ├── classifier_2_*.mem      # Memory initialization files for Classifier 2
│   └── classifier_3_*.mem      # Memory initialization files for Classifier 3
│
├─ sim/
│   └── prfc_top_tb.v           # testbench for pipeline simulation
│
├─ log/
│   └── prfc_test.log           # test log for prfc
```

- **`HW_source/`**: Contains all the synthesizable Verilog source code for the hardware design.
- **`prfc_top.v`**: The main module that instantiates all sub-modules and implements the core pipeline control logic.
- **`data/` directory**: This directory is crucial. It contains the pre-compiled rule sets. The `.mem` files are generated by an offline software tool (as described in the companion paper) and are used to initialize the BRAMs during synthesis or simulation. The logic itself is generic; the classification behavior is defined entirely by these memory files.
- **`sim/prfc_top_tb.v  `**: Contains the simulation-specific files(`prfc_top_tb.v`).
- **`log/prfc_test.log  `**: The simulation output file to show the classification result and how pipeline works

## How to Use and Simulate

1. **Setup**: Use a Verilog-capable EDA tool (e.g., Xilinx Vivado).
2. **Source Files**: Add all Verilog source files from the `HW_source/` directory to your project.
3. **Memory Initialization**: Ensure the synthesis/simulation environment is configured to locate the `.mem` files from the `data/` directory to initialize the BRAMs. This is a critical step for the design to function correctly.
4. **Top Module**: Set `prfc_top` as the top-level design unit.
5.**Simulation**:
   - Add the testbench file from `sim/prfc_top_tb.v` to your simulation set.
   - Run the simulation. The testbench will generate a log file at `./prfc_test.log`.

